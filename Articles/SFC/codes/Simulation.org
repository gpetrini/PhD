#+TITLE: SFC simulation report
#+AUTHOR: Gabriel Petrini
#+DATE: August, 2020
#+EMAIL: gpetrinidasilveira@gmail.com

* TODOs                                                            :noexport:

** TODO Check economic meaning of Real Shock Duration
** TODO Try to plug real data without Yeo-Jhonson Transformation
** TODO Check implications of demand leaks
** TODO Check implications of other $C_K$ growth rate

* Introductory setup                                               :noexport:




** Packages

#+BEGIN_SRC ipython  :async t :tangle setup.py :exports none :sessin
from pysolve3.model import Model
from pysolve3.utils import SolveSFC, ShockModel, SummaryShock, SFCTable

from datetime import datetime
t1 = datetime.now()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patheffects as pe
import seaborn as sns
import networkx as nx
import sympy as sp
from sympy import pprint, cse
#+END_SRC

#+RESULTS:
:results:
# Out [4]: 
:end:

** Model Class
   
#+BEGIN_SRC ipython  :session :async t :tangle setup.py :exports none
def model(
    alpha = 0.5, # Fazzarri Calibration
    gamma_F = 0.08,
    gamma_u = 0.09, # Fazzarri Calibration
    g_Z = 0.025, # Fazzarri Calibration
    omega = 0.5,
    rm = 0.01,
    spread_l = 0,
    spread_mo = 0,
    un = 0.8,
    v = 1.2, # Fazzarri Calibration
    phi_0 = 0.025, # Fazzarri Calibration
    phi_1 = 0.1,
    infla = 0.0,
    phparam=1.0,
    R = 0.7,
    real = -1, # Flags (Real Data)
    gC = 0.025 # (Real Data)
):
  """
  phparam: 1.0 means no inflation
  """
  model = Model()
  model.set_var_default(0) 
  model.var('C', desc='Consumption')
  model.var('Cw', desc='Workers Consumption', default=112)
  model.var('Ck', desc='Capitalist Consumption', default=68)
  model.var('FD', desc='Distributed profits')
  model.var('Fn', desc='Net profits')
  model.var('FT', desc='Total Profits')
  model.var('FU', desc='Retained profits')
  model.var('gk', desc='Capital growth rate')
  model.var('g_Z', desc='Autonomous grouth rate')
  model.var('h', desc='Marginal propensity to invest (non-residential)', default=0.03)
  model.var('I_t', desc='Investment', default = 100) # 200
  model.var('I_f', desc='Non-residential investment') # 100
  model.var('I_h', desc='Residential investment', default = 100) # 100
  model.var('Is', desc='Residential investment (Supply)', default = 100) # 100
  model.var('K_HS', desc='Houses supply', default=500) # 500
  model.var('K_HD', desc='Houses demand', default=500) # 500
  model.var('K_f', desc='Non-residential capital', default = 1000) # 10000
  model.var('Knom', desc='Nominal Capital', default=1500)
  model.var('K', desc='Real Capital', default=1500)
  model.var('K_k', desc="% of Kf in total")
  model.var('K_kr', desc="nominal % of Kf in total")
  model.var('L', desc='Total Loans') # 100
  model.var('Lf', desc='Firms Loans') # 100
  model.var('Lk', desc='Capitalist Loans') # 100
  model.var('M', desc='Money deposits') # 300
  model.var('M_h', desc='Households deposits')
  model.var('MO', desc='Mortgages') # 200
  model.var('NFW_h', desc='Households Capitalist Net Financial Wealth')
  model.var('NFW_hw', desc='Workers Net Financial Wealth', default=0)
  model.var('NFW_f', desc='Firms Net Financial Wealth')
  model.var('NFW_b', desc='Banks Net Financial Wealth')
  model.var('own', desc='Own interest rate')
  model.var('ph', desc='House price', default = 1)
  model.var('rl', desc='Interests rates on loans')
  model.var('rmo', desc='Interests rates on mortgages')
  model.var('S_hw', desc='Workers savings')
  model.var('S_hk', desc='Capitalist savings')
  model.var('u', desc='Capacity utilization ratio', default=0.7)
  model.var('V_h', desc='Household net nominal wealth')
  model.var('V_hr', desc='Household net real wealth')
  model.var('V_f', desc='Firms net wealth')
  model.var('V_b', desc='Banks net wealth')
  model.var('W', desc='Wages')
  model.var('Y', desc='GDP', default=280)
  model.var('Yk', desc='Capacity', default=1100)
  model.var('YDw', desc='Workers disposable income')
  model.var('YDk', desc='Capitalists disposable income')
  model.var('Z', desc='Autonomous expenditures')
  
  model.param('alpha', desc='Propensity to consume out of wages', default=alpha)
  model.param('gamma_F', desc='% of undistributed profits', default=gamma_F)
  model.param('gamma_u', desc='Adjustment parameter for the marginal propensity to invest', default=gamma_u) # 0.01
  model.param('omega', desc='Wage-share', default = omega)
  model.param('rm', desc='Interest rates on money deposits', default=rm) # 0.02
  model.param('spread_l', desc='Spread for loans', default=spread_l)
  model.param('spread_mo', desc='Spread for mortgages', default=spread_mo)
  model.param('un', desc='Normal capacity utilization ratio', default=un)
  model.param('v', desc='Capitl-Output ratio', default=v)
  model.param('phi_0', desc='Autonomous housing investment component',default = phi_0)
  model.param('phi_1', desc='Housing investment sensitivity to own interest rate', default = phi_1)
  model.param('R', desc='Autonomous ratio', default=R)
  model.param('infla', desc='infla value', default = infla)
  model.param('gC', desc='Autonomous consumption growth rate', default = gC)
  model.param('real', desc='Real data flag. True > 0. False < 0', default = real)  
  
  # General equations
  model.add('C = Cw + Ck')
  model.add('I_t = I_f + I_h') # Eq2
  model.add('Yk = K_f(-1)/v') # Eq 4
  model.add('u = Y/Yk') # Eq 5
  model.add('W = omega*Y') # Eq 6
  model.add('gk = h*u/v') # Eq 7
  model.add('Knom = K_HD*ph + K_f') # Eq 8 
  model.add('K = K_HD + K_f') # Eq 8 
  model.add('Z = I_h + Ck') # Eq 9
  model.add('Y = C + I_t') # Eq1
  
  # Workers equations
  model.add('Cw = alpha*W') # Eq 14
  model.add('YDw = W') # Eq 10
  model.add('S_hw = YDw - Cw') # Eq 11
  model.add('NFW_hw = S_hw')
    
  # Capitalist equations
  model.add('YDk = FD + rm*M_h(-1) - rmo*MO(-1) - rl*Lk(-1)')
  
  model.add('Ck = if_true(real>0)*(1+gC)*Ck(-1) + if_true(real<0)*R*Z')
  model.add('S_hk = YDk - Ck') # Eq 11
  model.add('d(MO) = I_h') # Eq 12
  model.add('d(Lk) = Ck')
  model.add('d(M_h) = S_hk + d(Lk)')
  model.add('V_h =  M_h  + K_HD*ph - MO - Lk') # Eq 15 
  model.add('V_hr =  M_h  + K_HD - MO - Lk') # Eq 15 
  model.add('NFW_h = S_hk - I_h') # Eq 16
  
  # Firms
  model.add('d(Lf) = I_f - FU') # Eq 15
  model.add('FT = (1-omega)*Y') # Eq 16
  model.add('Fn = FT -rl*Lf(-1)')
  model.add('FU = gamma_F*(Fn)') # Eq 17
  model.add('FD = (1 - gamma_F)*(Fn)') # Eq 18
  model.add('I_f = h*Y') # Eq 19
  model.add('d(K_f) = I_f') # 20
  model.add('h = h(-1)*gamma_u*(u-un) + h(-1)') # Eq 21 # Version without corridor
  model.add('V_f = K_f - Lf') # Eq 22
  model.add('NFW_f = FU - I_f') # Eq 23
  
  # Banks
  model.add('rmo = (1+spread_mo)*rm') # Eq 25
  model.add('rl = (1+spread_l)*rm') # Eq 26
  model.add('NFW_b = rl*L(-1) + rmo*MO(-1) - rm*M(-1)') # Eq 28
  model.add('V_b = L + MO - M') # Eq 27
  model.add('d(L) = d(Lf) + d(Lk)')
  model.add('d(M) = d(M_h)')
  
  
  # Residential investment
  model.add('K_HS = K_HD') # Eq 29
  model.add('Is = I_h')
  model.add('d(K_HD) = I_h') # Eq 30
  model.add('I_h = (1+g_Z)*I_h(-1)') # Eq 31
  model.add('K_k = K_HD/K') 
  model.add('K_kr = K_k*ph') 
  model.add('ph =(1+infla)*ph(-1)')
  model.add('own = ((1+rmo)/(1+infla)) -1')  
  model.add('g_Z = phi_0 - phi_1*own') 
  
  return model

#+END_SRC

#+RESULTS:
:results:
# Out [743]: 
:end:

** Functions

*** Plot Functions

#+BEGIN_SRC ipython  :session :assync t :tangle setup.py :exports none
  def clock_plots(shock, filename, variable):
      shock["TIME"] = [i+1 for i in range(len(shock.index))]
      shock["Ih/Y"] = shock["I_h"]/shock["Y"]
      shock["I/Y"] = shock["I_t"]/shock["Y"]
      shock["Z/Y"] = shock["Z"]/shock["Y"]
      shock["gY"] = shock["Y"].pct_change()

      sns.set_context('talk')
      fig, ax = plt.subplots(1,3,figsize=(24,5)
                            )

      sns.scatterplot(y = 'Ih/Y', x='u', data=shock, size="TIME", sizes = (1,200), 
                      color = 'black', legend=False, ax=ax[0])
      sns.lineplot(y = 'Ih/Y', x='u', data=shock, sort=False, color = 'black', ax=ax[0])
      ax[0].set_title("(A) Residential investment share on GDP\n VS. Capacity utilization ratio")

      sns.scatterplot(y = 'Z/Y', x='u', data=shock, size="TIME", sizes = (1,200), color = 'black', legend=False, ax=ax[1])
      sns.lineplot(y = 'Z/Y', x='u', data=shock, sort=False, color = 'black', ax=ax[1])
      ax[1].set_title("(B) Autonomous Expenditure share\n VS Capacity utilization")

      sns.scatterplot(y = 'I/Y', x='gY', data=shock, size="TIME", sizes = (1,200), color = 'black', legend=False, ax=ax[2])
      sns.lineplot(y = 'I/Y', x='gY', data=shock, sort=False, color = 'black', ax=ax[2])
      ax[2].set_title("(C) Total investment share\n VS GDP growth rate")


      sns.despine()

      fig.savefig("./figs/" + filename, dpi = 600)

  def plot_shock(filename, shock, df):
      """
      This function plots some selected variables

      filename: name to save the plot (str)
      shock: df returned by ShockModel function
      """
      sns.set_context('talk')
      fig, ax = plt.subplots(2,2, figsize=(16,10))

      shock[["Y"]].pct_change().plot(
          title = "Growth rates", ax = ax[0,0], 
          ls = ('--'), lw=3,
      )
      shock[["K"]].pct_change().plot(
          title = "Growth rates", ax = ax[0,0], 
          ls = (':'), lw=3
      )
      shock[["I_h"]].pct_change().plot(
          title = "Growth rates", ax = ax[0,0], 
          ls = ('-'), lw=3,
      )
      shock[["I_f"]].pct_change().plot(
          title = "Growth rates", ax = ax[0,0], 
          ls = ('-.'), lw=3,
      )
      ax[0,0].axhline(y=shock["g_Z"].iloc[-1], color = "black", ls = "--", lw=2.5)
      #ax[0,0].set_yticklabels(['{:,.1%}'.format(x) for x in ax[0,0].get_yticks()])
      ax[0,0].legend(loc='upper center', bbox_to_anchor=(0.5, -0.06),
                     labels = ["$Y$", "$K$", "$I_h$", "$I_f$"],
                fancybox=True, shadow=True, ncol=2)
      ax[0,0].ticklabel_format(useOffset=False)

      ((shock["Z"]/shock['Y'])).plot(
          title = "Autonomous expenditures share on GDP", ax = ax[0,1], ls = ('-'), lw=3, color='darkred')

      ax[0,1].set_ylim(auto=True)
      ax[0,1].legend(loc='upper center', bbox_to_anchor=(0.5, -0.08),
                     labels=['$Z/Y$'],
                fancybox=True, shadow=True, ncol=2)

      shock['u'].plot(title = 'Capacity utilization ratio', ax=ax[1,0], legend = False, color = "darkred", lw = 3, )
      ax[1,0].axhline(y = shock['un'].iloc[-1], ls ='--', color = "gray")
      #ax[1,0].set_yticklabels(['{:,.2%}'.format(x) for x in ax[1,0].get_yticks()])
      ax[1,0].ticklabel_format(useOffset=False)

      shock['h'].plot(title = 'Marginal propensity to invest', ax=ax[1,1], legend = False, color = "darkred", lw = 3, )
      ax[1,1].axhline(y = df['h'].iloc[-1], ls ='--', color = "gray")
      ax[1,1].ticklabel_format(useOffset=False)

      sns.despine()
      plt.tight_layout(rect=[0, 0.03, 1, 0.95])

      fig.savefig("./figs/" + filename, dpi = 600)
      plt.show()


  def plot_norms(filename, shock, df):
      """
      This function plots some selected variables

      filename: name to save the plot (str)
      shock: df returned by ShockModel function
      """
      sns.set_context('talk')
      fig, ax = plt.subplots(2,2, figsize=(16,10))

      ((shock["YDk"]/shock['V_h'])**(1)).plot(title = "Flow/Stock", ax = ax[0,0], ls = (':'), lw=3)
      ((shock["YDk"]/shock['V_hr'])**(1)).plot(ax = ax[0,0], ls = ('-'), lw=3)
      ((shock["FU"]/shock['V_f'])**(1)).plot(ax = ax[0,0], ls = ('-'), lw=3)

      ax[0,0].set_yticklabels(['{:,.1%}'.format(x) for x in ax[0,0].get_yticks()])
      ax[0,0].legend(loc='upper center', bbox_to_anchor=(0.5, -0.08),
                     labels = [
                         "$YDk/V_{hk}$",
                         "$YDk/V_{hkr}$",
                         "$FU$/V_f",
                              ],
                fancybox=True, shadow=True, ncol=2)
      #ax[0,0].ticklabel_format(useOffset=False)

      shock['K_k'].plot(color = "darkred", 
                        title = "Housing share on\nTotal Capital Stock", 
                        label = "$\k$", legend = False, ax = ax[0,1], lw = 3, )
      ax[0,1].axhline(y = df['K_k'].iloc[-1], ls ='--', color = "gray")
      ax[0,1].ticklabel_format(useOffset=False)

      (shock["MO"]*shock["rmo"][1:]/shock['YDk'][1:]).plot(
          title="Debt service on\nDisposable income", ax = ax[1,0], ls = ('-'), lw=3)
      ((shock["Lk"]*shock["rl"][1:])/shock['YDk'][1:]).plot(ax = ax[1,0], ls = ('-'), lw=3)
      ((shock["MO"]*shock["rmo"][1:] + shock["Lk"]*shock["rl"][1:])/shock['YDk'][1:]).plot( ax = ax[1,0], ls = ('-'), lw=3)
      ax[1,0].set_yticklabels(['{:,.1%}'.format(x) for x in ax[1,0].get_yticks()])
      ax[1,0].legend(loc='upper center', bbox_to_anchor=(0.5, -0.1),
                     labels = [
                         'Mortgage',
                         'Loans',
                         'Total'
                              ],
                fancybox=True, shadow=True, ncol=2)

      (shock['FT']/shock['K_f']).plot(ax=ax[1,1], label='Gross profit rate')
      (shock['Fn']/shock['K_f']).plot(ax=ax[1,1], label='Net profit rate')
      ax[1,1].set_yticklabels(['{:,.1%}'.format(x) for x in ax[1,0].get_yticks()])
      ax[1,1].legend()


      sns.despine()
      plt.tight_layout(rect=[0, 0.03, 1, 0.95])

      fig.savefig("./figs/" + filename, dpi = 300)

  def other_plots(shock, df):

      (shock['MO']/(shock['M'])).plot(title="Mortgage as % of deposits")
      sns.despine()

      fig, ax = plt.subplots()
      (shock['FT']/shock['K_f']).plot(ax=ax, label='Gross profit rate')
      (shock['Fn']/shock['K_f']).plot(ax=ax, label='Net profit rate')
      ax.legend()
      sns.despine()

      fig, ax = plt.subplots()
      (shock['YDk']/shock['K_HD']).plot(ax=ax, label='Real', title="Disposible income as % of Housing")
      (shock['YDk']/(shock['K_HD']*shock['ph'])).plot(ax=ax, label='Nominal')
      ax.legend()
      sns.despine()

      fig, ax = plt.subplots()
      (shock['NFW_h']/(shock['Lk'] + shock['MO']) - (shock['rm'] - shock['g_Z'])).plot(title = 'Household debt stability',ax=ax)
      ax.axhline(y = ((df['NFW_h']/(df['Lk'] + df['MO'])) - (df['rm'] - df['g_Z'])).iloc[-1], ls ='--', color = "gray")

      sns.despine()
      plt.tight_layout(rect=[0, 0.03, 1, 0.95])

      fig, ax = plt.subplots(1,1, figsize=(8,5))

      shock[["MO", "L"]].apply(lambda x: x/(shock["MO"] + shock['L'])).plot(kind = "area",stacked = True ,title = "Credit (as % Passives)", ax=ax)
      ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))
      ax.axhline(y = 1, color = "black", ls = "--")
      ax.axhline(y = 0, color = "black", ls = "--")

      sns.despine()
      plt.tight_layout(rect=[0, 0.03, 1, 0.95])
#+END_SRC

#+RESULTS:
:results:
# Out [727]: 
:end:

*** Sobol Fenectano

#+BEGIN_SRC ipython :session py :async t :tangle setup.py :exports none :kernel python3
def sobol(
    parameters,
    bound = np.linspace(0,1,101),
    time = 10,
    skip = 10,
    filename="Sobol.eps",
    var = "u"
):
    t2 = datetime.now()
    bound = bound
    df = pd.DataFrame()
    empty_list = [i for i in range(len(bound))]  
    
    for param in parameters:
        for i in range(len(bound)):
            base = model()
            base.set_values({param:bound[i]})
            try:
                empty_list[i] = np.log(SolveSFC(base,time=time+skip)[var][skip:].std())
            except Exception as e:
                empty_list[i] = np.infty
                pass
        df[param] = empty_list ################### Replace here
############################### End #####################################################
    df.index = bound
    
    sns.set_context('talk')
    fig, ax = plt.subplots()

    df.plot(
        ax = ax,
        lw = 2.5
    )
    ax.ticklabel_format(useOffset=False)
    ax.set_ylabel(f"$\log(std({var}))$")
    ax.set_xlabel("Parameters")
    ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))

    fig.suptitle("Sensibility analysis", fontsize = 14, weight="bold")
    ax.set_title("Simulation duration is {} periods (desconsidering firsts {}lags)".format(time+skip,skip), fontsize = 12, y = .98)

    ylim = ax.get_ylim()
    fig.savefig("../figs/" + filename, dpi = 300)
    plt.show()
    print("Total running time: ", datetime.now()-t2)
    return df
#+END_SRC

#+RESULTS:
:results:
# Out [4]: 
:end:



* Symbolic Solution                                                  
  
** Start up                                                        :noexport:

#+BEGIN_SRC ipython :session  :exports none :assync t :tangle Symbolic_Solution.py :results output
base = model()
df = SolveSFC(base, time=1000)

base_eq = model()
SolveSFC(base_eq, time=1, table = False)
t = sp.Symbol('t')
initials = {
    key: base_eq.evaluate(key) for key in base_eq.parameters
}
initials.update({key: base_eq.evaluate(key) for key in base_eq.variables})

for i in base_eq.variables:
  globals()["_" + i] = sp.Function(i)
  
for i in base_eq.parameters:
  globals()[i] = sp.symbols(i, positive=True)
  globals()['infla'] = sp.symbols('infla')
#+END_SRC

#+RESULTS:
:results:
# Out [728]: 
:end:

** Creating equations                                              :noexport:

*** General Equations

#+BEGIN_SRC ipython  :session :exports none :assync t :tangle Symbolic_Solution.py :results output
Y = _C(t) + _I_t(t)
pprint(sp.Eq(_Y(t), Y))
C = _Cw(t) + _Ck(t)
pprint(sp.Eq(_C(t), C))
I = _I_f(t) + _I_h(t)
pprint(sp.Eq(_I_t(t), I))
Yk = _K_f(t)/v
pprint(sp.Eq(_Yk(t), Yk))
u = _Y(t)/_Yk(t)
pprint(sp.Eq(_u(t), u))
Z = _I_h(t)
pprint(sp.Eq(_Z(t), Z))
W = omega*_Y(t)
pprint(sp.Eq(_W(t), W))
K = _K_HD(t) + _K_f(t)
pprint(sp.Eq(_K(t), K))
Z = _Ck(t) + _I_h(t)
pprint(sp.Eq(_Z(t), Z))
#+END_SRC

#+RESULTS:
:results:
# Out [729]: 
# output
Y(t) = C(t) + Iₜ(t)
C(t) = Ck(t) + Cw(t)
Iₜ(t) = I_f(t) + Iₕ(t)
        K_f(t)
Yk(t) = ──────
          v   
        Y(t)
u(t) = ─────
       Yk(t)
Z(t) = Iₕ(t)
W(t) = ω⋅Y(t)
K(t) = K_HD(t) + K_f(t)
Z(t) = Ck(t) + Iₕ(t)

:end:

*** Workers

#+BEGIN_SRC ipython :session  :exports none :assync t :tangle Symbolic_Solution.py :results output
Cw = alpha*_W(t)
pprint(sp.Eq(_Cw(t), Cw))
YDw = _W(t)
pprint(sp.Eq(_YDw(t), YDw))
S_hw = _YDk(t) - _Cw(t)
pprint(sp.Eq(_S_hw(t), S_hw))
NFW_hw = _S_hw(t)
pprint(sp.Eq(_NFW_hw(t), NFW_hw))
#+END_SRC

#+RESULTS:
:results:
# Out [730]: 
# output
Cw(t) = α⋅W(t)
YDw(t) = W(t)
S_hw(t) = -Cw(t) + YDk(t)
NFW_hw(t) = S_hw(t)

:end:

*** Capitalists

#+BEGIN_SRC ipython :session :exports none :assync t :tangle Symbolic_Solution.py :results output
Ck = R*_Z(t)
pprint(sp.Eq(_Ck(t), Ck))
dLk = _Ck(t)
pprint(sp.Eq(_Lk(t) - _Lk(t-1), dLk))
YDk = _FD(t) + rm*_M_h(t-1) - _rmo(t)*_MO(t-1) - _rl(t)*_Lk(t-1)
pprint(sp.Eq(_YDk(t), YDk))
S_hk = _YDk(t) - _Ck(t)
pprint(sp.Eq(_S_hk(t), S_hk))
dMO = _I_h(t)
pprint(sp.Eq(_MO(t) - _MO(t-1), dMO))
dM_h = _S_hk(t) + (_Lk(t) - _Lk(t-1))
pprint(sp.Eq((_M_h(t) - _M_h(t-1)), dM_h))
V_h = _M_h(t) + _K_HD(t)*_ph(t) - _MO(t) - _Lk(t)
pprint(sp.Eq(_V_h(t), V_h))
V_hr = _M_h(t) + _K_HD(t) - _MO(t) - _Lk(t)
pprint(sp.Eq(_V_hr(t), V_hr))
NFW_h = _S_hk(t) - _I_h(t)
pprint(sp.Eq(_NFW_h(t), NFW_h))
M_h = _S_hk(t) + (_Lk(t) - _Lk(t-1))
pprint(sp.Eq(_M_h(t), M_h))
#+END_SRC

#+RESULTS:
:results:
# Out [731]: 
# output
Ck(t) = R⋅Z(t)
Lk(t) - Lk(t - 1) = Ck(t)
YDk(t) = rm⋅Mₕ(t - 1) + FD(t) - Lk(t - 1)⋅rl(t) - MO(t - 1)⋅rmo(t)
Sₕₖ(t) = -Ck(t) + YDk(t)
MO(t) - MO(t - 1) = Iₕ(t)
Mₕ(t) - Mₕ(t - 1) = Lk(t) - Lk(t - 1) + Sₕₖ(t)
Vₕ(t) = K_HD(t)⋅ph(t) - Lk(t) - MO(t) + Mₕ(t)
Vₕᵣ(t) = K_HD(t) - Lk(t) - MO(t) + Mₕ(t)
NFWₕ(t) = -Iₕ(t) + Sₕₖ(t)
Mₕ(t) = Lk(t) - Lk(t - 1) + Sₕₖ(t)

:end:

*** Firms
    

#+BEGIN_SRC ipython :session :exports none :assync t :tangle Symbolic_Solution.py :results output
I_f = _h(t)*_Y(t)
pprint(sp.Eq(_I_f(t), I_f))
dK_f = _I_f(t)
pprint(sp.Eq(_K_f(t) - _K_f(t-1), dK_f))
Lf = _I_f(t) - _FU(t) + _Lf(t-1)
pprint(sp.Eq(_Lf(t), Lf))
FT = _FU(t) + _FD(t)
pprint(sp.Eq(_FT(t), FT))
FU = gamma_F*(_FT(t) - _rl(t)*_Lf(t-1))
pprint(sp.Eq(_FU(t), FU))
FD = (1 - gamma_F)*(_FT(t) - _rl(t)*_Lf(t-1))
pprint(sp.Eq(_FD(t), FD))
h = _h(t-1)*gamma_u*(_u(t)-un) + _h(t-1)
pprint(sp.Eq(_h(t), h))
NFW_f = _FU(t) - _I_f(t)
pprint(sp.Eq(_NFW_f(t), NFW_f))
V_f = _K_f(t) - _Lf(t)
pprint(sp.Eq(_V_f(t), V_f))
#+END_SRC

#+RESULTS:
:results:
# Out [732]: 
# output
I_f(t) = Y(t)⋅h(t)
K_f(t) - K_f(t - 1) = I_f(t)
Lf(t) = -FU(t) + I_f(t) + Lf(t - 1)
FT(t) = FD(t) + FU(t)
FU(t) = γ_F⋅(FT(t) - Lf(t - 1)⋅rl(t))
FD(t) = (1 - γ_F)⋅(FT(t) - Lf(t - 1)⋅rl(t))
h(t) = γᵤ⋅(-un + u(t))⋅h(t - 1) + h(t - 1)
NFW_f(t) = FU(t) - I_f(t)
V_f(t) = K_f(t) - Lf(t)

:end:

*** Banks

#+BEGIN_SRC ipython  :session  :exports none :assync t :tangle Symbolic_Solution.py :results output
L = _Lf(t) + _Lk(t)
pprint(sp.Eq(_L(t), L))
M = (_L(t) - _L(t-1)) + (_MO(t) - _MO(t-1)) + _M(t-1)
pprint(sp.Eq(_M(t), M))
rmo = (1+ spread_mo)*rm
pprint(sp.Eq(_rmo(t), rmo))
rl = (1+ spread_l)*rm
pprint(sp.Eq(_rl(t), rl))
V_b = _L(t) + _MO(t) - _M(t)
pprint(sp.Eq(_V_b(t), V_b))
NFW_b = _rl(t)*_L(t-1) + _rmo(t)*_MO(t-1) - rm*_M(t-1)
pprint(sp.Eq(_NFW_b(t), NFW_b))
#+END_SRC

#+RESULTS:
:results:
# Out [733]: 
# output
L(t) = Lf(t) + Lk(t)
M(t) = L(t) - L(t - 1) + M(t - 1) + MO(t) - MO(t - 1)
rmo(t) = rm⋅(spreadₘₒ + 1)
rl(t) = rm⋅(spreadₗ + 1)
V_b(t) = L(t) - M(t) + MO(t)
NFW_b(t) = -rm⋅M(t - 1) + L(t - 1)⋅rl(t) + MO(t - 1)⋅rmo(t)

:end:

*** Residential investment 
    
#+BEGIN_SRC ipython :session  :exports none :assync t :tangle Symbolic_Solution.py :results output
_own = sp.Function('own')

K_HS = _K_HD(t)
pprint(sp.Eq(_K_HS(t), K_HS))
Is = _I_h(t)
pprint(sp.Eq(_Is(t), Is))
dK_HD = _I_h(t)
pprint(sp.Eq(_K_HD(t) - _K_HD(t-1), dK_HD))
I_h = (1+_g_Z(t))*_I_h(t-1)
pprint(sp.Eq(_I_h(t), I_h))
K_k = _K_HD(t)/(_K(t))
pprint(sp.Eq(_K_k(t), K_k))
ph = (1+infla)*_ph(t-1)
pprint(sp.Eq(_ph(t), ph))
own = ((1+_rmo(t))/(1+infla))-1
pprint(sp.Eq(_own(t), own))
g_Z = phi_0 - phi_1*_own(t)
pprint(sp.Eq(_g_Z(t), g_Z))
#+END_SRC

#+RESULTS:
:results:
# Out [734]: 
# output
K_HS(t) = K_HD(t)
Is(t) = Iₕ(t)
K_HD(t) - K_HD(t - 1) = Iₕ(t)
Iₕ(t) = (g_Z(t) + 1)⋅Iₕ(t - 1)
        K_HD(t)
Kₖ(t) = ───────
          K(t) 
ph(t) = (infla + 1)⋅ph(t - 1)
              rmo(t) + 1
own(t) = -1 + ──────────
              infla + 1 
g_Z(t) = φ₀ - φ₁⋅own(t)

:end:





* Simulations                                                      

#+BEGIN_SRC ipython :session  :exports results :assync t :tangle Results.py :results output
%config InlineBackend.figure_format = 'retina'

df = SolveSFC(model(), time=1000)
#+END_SRC

#+RESULTS:
:results:
# Out [735]: 
:end:


** Consistency check                                               :noexport:


#+BEGIN_SRC ipython  :session :exports results :assync t :tangle Results.py :results output
t_check = 1
print('Evaluating at time = {}'.format(t_check))

test = model()
SolveSFC(test, time=t_check, table = False)
evaldf = pd.DataFrame({
    'Cw' : test.evaluate('Cw'),
    'Ck' : test.evaluate('Ck'),
    'I_h' : test.evaluate('I_h'),
    'I_f' : test.evaluate('I_f'),
    'K_f(-1)' : test.evaluate('K_f(-1)'),
    'Yk' : test.evaluate('Yk'),
    'Y' : test.evaluate('Y'),
    'gk' : test.evaluate('gk'),
    'u' : test.evaluate('u'),
    "Residual" : test.evaluate('d(L) + d(MO) - d(M)')
}, index = ['Sum'])
evaldf = evaldf.transpose()
evaldf.round(5)
#+END_SRC

#+RESULTS:
:results:
# Out [736]: 
# output
Evaluating at time = 1

# text/plain
:                  Sum
: Cw         118.41513
: Ck         238.93286
: I_h        102.40000
: I_f         13.91363
: K_f(-1)   1013.91363
: Yk         833.33333
: Y          473.66118
: gk           0.01391
: u            0.56839
: Residual     0.00000

[[file:/tmp/ob-ipython-htmlaEKL4E.html]]
:end:


** Solving

#+BEGIN_SRC ipython :session  :assync t :tangle Results.py :results raw drawer :exports results
%matplotlib inline
base = model()
df = SolveSFC(base, time=1000)
df_base = df.copy()
df = df[100:].copy()
fig, ax = plt.subplots(1,3, figsize=(24,5))

df.loc[:,"TIME"] = [i+1 for i in range(len(df.index))]
df.loc[:,"Ih/Y"] = df.loc[:,"I_h"]/df.loc[:,"Y"]
df.loc[:,"I/Y"] = df.loc[:,"I_t"]/df.loc[:,"Y"]
df.loc[:,"Z/Y"] = df.loc[:,"Z"]/df.loc[:,"Y"]
df.loc[:,"gY"] = df.loc[:,"Y"].pct_change()

sns.scatterplot(y = 'Ih/Y', x='u', data=df, size="TIME", sizes = (1,100), color = 'black', legend=False, ax=ax[0])
sns.lineplot(y = 'Ih/Y', x='u', data=df, sort=False, color = 'black', ax=ax[0])

sns.scatterplot(y = 'Z/Y', x='u', data=df, size="TIME", sizes = (1,100), color = 'black', legend=False, ax=ax[1])
sns.lineplot(y = 'Z/Y', x='u', data=df, sort=False, color = 'black', ax=ax[1])

sns.scatterplot(y = 'I/Y', x='gY', data=df, size="TIME", sizes = (1,100), color = 'black', legend=False, ax=ax[2])
sns.lineplot(y = 'I/Y', x='gY', data=df, sort=False, color = 'black', ax=ax[2])

plt.tight_layout()
plt.show()
#+END_SRC

#+RESULTS:
:results:
# Out [737]: 
# text/plain
: <Figure size 1728x360 with 3 Axes>

# image/png
[[file:obipy-resources/833ba20b4aec1c9746a2e4fcac62a826eabb201d/edb75400eaa242706d333a5892dc23b807e4fa06.png]]
:end:

#+BEGIN_SRC ipython :session :assync t :tangle Results.py :results raw drawer :exports results
fig, ax = plt.subplots(2,2, figsize=(16,10))

df[['Lf', "M_h", "MO", "Lk"]][:100].plot(ax=ax[0,0], title='Financial Assets')

df[['FT', "FU", "FD", "Fn"]][:100].plot(title='Profitss', ax=ax[0,1])

df['h'].plot(color = "black", ls="-",  title = "Marginal propensity to invest", 
             label = "$h_t$", legend = True,ax=ax[1,0])

df[["Y", "K", "I_h", "I_f"]][40:].pct_change().plot(title = "Growth rates",ax=ax[1,1])
ax[1,1].set_yticklabels(['{:,.2%}'.format(x) for x in ax[1,1].get_yticks()])
ax[1,1].axhline(y=df["g_Z"].iloc[-1], color = "black", ls = "--", lw=1)
ax[1,1].legend(loc='center left', bbox_to_anchor=(1, 0.5))


plt.tight_layout()
plt.show()
#+END_SRC

#+RESULTS:
:results:
# Out [738]: 
# text/plain
: <Figure size 1152x720 with 4 Axes>

# image/png
[[file:obipy-resources/833ba20b4aec1c9746a2e4fcac62a826eabb201d/b1ab5d28b5a916ccd61a2da68541c183d68a4e01.png]]
:end:

#+BEGIN_SRC ipython :session :assync t :tangle Results.py :results raw drawer :exports results
fig, ax = plt.subplots(2,2, figsize=(16,10))


df[["K"]].pct_change().plot(ax=ax[0,0], color='black', title='Capital growth rate')

df['Y'].pct_change().plot(color = "black", title = "GDP growth rate", label = "$Y_t$", legend = True, ax=ax[0,1])
ax[0,1].axhline(y=df["g_Z"].iloc[-1], color = "red", ls = "--", lw=1, label = "Autonomous growth rate")
ax[0,1].set_yticklabels(['{:,.2%}'.format(x) for x in ax[0,1].get_yticks()])

df['K_k'].plot(color = "black", title = "Housing as % of total capital", label = "$k$", legend = True, ax=ax[1,0])
ax[1,0].set_yticklabels(['{:,.0%}'.format(x) for x in ax[1,0].get_yticks()])

df['un'].plot(color = "red", ls="--",  title = "Capacity utilization ratio", label = "$un$", legend = True,ax=ax[1,1])
df['u'].plot(color = "black", title = "Capacity utilization ratio", label = "$u_t$", legend = True, ax=ax[1,1])
#ax[1,1].set_yticklabels(['{:,.1%}'.format(x) for x in ax[1,1].get_yticks()])

plt.tight_layout()
plt.show()
#+END_SRC

#+RESULTS:
:results:
# Out [739]: 
# text/plain
: <Figure size 1152x720 with 4 Axes>

# image/png
[[file:obipy-resources/833ba20b4aec1c9746a2e4fcac62a826eabb201d/8553cac7719c5823ba4bd17e31ed9e468f656cb9.png]]
:end:

#+BEGIN_SRC ipython :session :assync t :tangle Results.py :results raw drawer :exports results
fig, ax = plt.subplots(2,2, figsize=(16,10))

df[["V_b", "V_h", "V_f"]].plot(title = "Net Wealth", ax=ax[0,0])

df[['V_b', 'V_h', 'V_f']].apply(lambda x: np.abs(x)/df['K']).plot(kind = 'area', stacked = True, 
                                                                  title = "Net wealth (as % K)", ax=ax[0,1])
ax[0,1].set_yticklabels(['{:,.0%}'.format(x) for x in ax[0,1].get_yticks()])
ax[0,1].axhline(y=1, color = "black", ls = "--", lw=1)
ax[0,1].legend(loc='center left', bbox_to_anchor=(1, 0.5))

((df['V_b'] + df['V_f'] + df['V_h'])/df['K']).plot(label='Consistensy check', color='black', ax=ax[1,0])
ax[1,0].axhline(y=1, color = "black", ls = "--", lw=1)

df[["NFW_b", "NFW_h", "NFW_f"]].plot(title = "Net Financial Wealth", ax=ax[1,1])

plt.tight_layout()
plt.show()
#+END_SRC

#+RESULTS:
:results:
# Out [740]: 
# text/plain
: <Figure size 1152x720 with 4 Axes>

# image/png
[[file:obipy-resources/833ba20b4aec1c9746a2e4fcac62a826eabb201d/11f3f05ec76746c8aa34965d6b2ffc36e7ec603a.png]]
:end:

#+BEGIN_SRC ipython :session :assync t :tangle Results.py :results raw drawer :exports results
fig, ax = plt.subplots(1,2, figsize=(16,10))

df['V_b'].plot(title = "Banks Net Wealth", ax=ax[0])
df[["MO", "L"]].apply(lambda x: x/(df["MO"] + df['L'])).plot(kind = "area",stacked = True ,
                                                             title = "Credit (as % Liabilities)", ax=ax[1])
ax[1].legend(loc='center left', bbox_to_anchor=(1, 0.5))
ax[1].axhline(y = 1, color = "black", ls = "--")
ax[1].axhline(y = 0, color = "black", ls = "--")

sns.despine()
plt.tight_layout()
plt.show()

df.transpose()
#+END_SRC

#+RESULTS:
:results:
# Out [741]: 
# text/plain
:              100          101          102          103          104   \
: C     3765.134938  3855.863961  3948.736973  4043.803678  4141.115084   
: Cw    1264.970108  1295.695180  1327.124143  1359.272144  1392.154796   
: Ck    2500.175522  2560.179735  2621.624049  2684.543026  2748.972058   
: FD    2341.126764  2397.480047  2455.114187  2514.057576  2574.339527   
: Fn    2544.703005  2605.956573  2668.602378  2732.671278  2798.195138   
: ...           ...          ...          ...          ...          ...   
: TIME     1.000000     2.000000     3.000000     4.000000     5.000000   
: Ih/Y     0.211765     0.211705     0.211652     0.211606     0.211566   
: I/Y      0.255887     0.256027     0.256150     0.256258     0.256350   
: Z/Y      0.705880     0.705681     0.705504     0.705350     0.705218   
: gY            NaN     0.024289     0.024256     0.024224     0.024191   
: 
:              105          106          107          108          109   ...  \
: C     4240.723534  4342.682743  4447.047840  4553.856910  4663.204510  ...   
: Cw    1425.788200  1460.188963  1495.374209  1531.354473  1568.162016  ...   
: Ck    2814.947388  2882.506125  2951.686272  3022.520925  3095.061426  ...   
: FD    2635.990307  2699.041168  2763.524372  2829.464035  2896.912612  ...   
: Fn    2865.206856  2933.740400  3003.830839  3075.504386  3148.818057  ...   
: ...           ...          ...          ...          ...          ...  ...   
: TIME     6.000000     7.000000     8.000000     9.000000    10.000000  ...   
: Ih/Y     0.211533     0.211507     0.211487     0.211474     0.211467  ...   
: I/Y      0.256427     0.256489     0.256535     0.256567     0.256585  ...   
: Z/Y      0.705108     0.705020     0.704954     0.704910     0.704885  ...   
: gY       0.024159     0.024128     0.024096     0.024062     0.024036  ...   
: 
:               991           992           993           994           995   \
: C     5.641294e+12  5.776685e+12  5.915325e+12  6.057293e+12  6.202668e+12   
: Cw    1.880928e+12  1.926071e+12  1.972297e+12  2.019632e+12  2.068103e+12   
: Ck    3.760381e+12  3.850630e+12  3.943045e+12  4.037678e+12  4.134583e+12   
: FD    3.472855e+12  3.556204e+12  3.641553e+12  3.728951e+12  3.818446e+12   
: Fn    3.774843e+12  3.865439e+12  3.958210e+12  4.053207e+12  4.150484e+12   
: ...            ...           ...           ...           ...           ...   
: TIME  8.920000e+02  8.930000e+02  8.940000e+02  8.950000e+02  8.960000e+02   
: Ih/Y  2.142019e-01  2.142019e-01  2.142019e-01  2.142019e-01  2.142019e-01   
: I/Y   2.502006e-01  2.502006e-01  2.502007e-01  2.502007e-01  2.502007e-01   
: Z/Y   7.140033e-01  7.140032e-01  7.140032e-01  7.140032e-01  7.140031e-01   
: gY    2.400005e-02  2.400005e-02  2.400005e-02  2.400006e-02  2.400006e-02   
: 
:               996           997           998           999           1000  
: C     6.351533e+12  6.503969e+12  6.660065e+12  6.819907e+12  6.983584e+12  
: Cw    2.117738e+12  2.168563e+12  2.220609e+12  2.273904e+12  2.328478e+12  
: Ck    4.233813e+12  4.335424e+12  4.439474e+12  4.546022e+12  4.655126e+12  
: FD    3.910089e+12  4.003931e+12  4.100026e+12  4.198426e+12  4.299189e+12  
: Fn    4.250096e+12  4.352099e+12  4.456550e+12  4.563507e+12  4.673032e+12  
: ...            ...           ...           ...           ...           ...  
: TIME  8.970000e+02  8.980000e+02  8.990000e+02  9.000000e+02  9.010000e+02  
: Ih/Y  2.142019e-01  2.142019e-01  2.142019e-01  2.142018e-01  2.142018e-01  
: I/Y   2.502007e-01  2.502008e-01  2.502008e-01  2.502008e-01  2.502009e-01  
: Z/Y   7.140031e-01  7.140030e-01  7.140030e-01  7.140030e-01  7.140029e-01  
: gY    2.400006e-02  2.400006e-02  2.400006e-02  2.400006e-02  2.400006e-02  
: 
: [80 rows x 901 columns]

[[file:/tmp/ob-ipython-html8eVtTh.html]]

# text/plain
: <Figure size 1152x720 with 2 Axes>

# image/png
[[file:obipy-resources/833ba20b4aec1c9746a2e4fcac62a826eabb201d/2c047f9da9769dec6676c8b78dbd7b58ee5d8285.png]]
:end:

#+BEGIN_SRC ipython :session  :exports none :assync t :tangle Results.py :results output

#+END_SRC

#+RESULTS:
:results:
# Out [741]: 
:end:


** Shocks

*** Increase in autonomous growth rate ($g_Z$)

#+BEGIN_SRC ipython :session :assync t :tangle Results.py :results output drawer :exports results
base = model()
df = SolveSFC(base, time=1000)
shock = ShockModel(base_model=base, create_function=model(), variable='phi_0', increase=0.005, time = 1000)
clock_plots(shock = shock, filename = 'Clock1.png', variable='g_Z')
plot_shock(shock = shock, filename = 'Shock1.png', df=df)
plot_norms(shock = shock, filename = 'Shock1Norms.png', df=df)
other_plots(shock, df=df)

shock1 = shock.round(decimals = 5).tail(1).transpose().loc['alpha':,:]
shock1.columns = ['$\Delta \phi_0$']

summary = SummaryShock(shock)
summary
#+END_SRC

#+RESULTS:
:results:
# Out [742]: 
# text/plain
:                  0         Shock             1             2             3  \
: C     2.286001e+13  2.352303e+13  2.420550e+13  2.490790e+13  2.563082e+13   
: Cw    7.622032e+12  7.843186e+12  8.070931e+12  8.305424e+12  8.546874e+12   
: Ck    1.523805e+13  1.567993e+13  1.613465e+13  1.660256e+13  1.708403e+13   
: FD    1.407295e+13  1.448104e+13  1.490128e+13  1.533397e+13  1.577948e+13   
: Fn    1.529668e+13  1.574027e+13  1.619705e+13  1.666736e+13  1.715161e+13   
: ...            ...           ...           ...           ...           ...   
: TIME  5.100000e+01  5.200000e+01  5.300000e+01  5.400000e+01  5.500000e+01   
: Ih/Y  2.142014e-01  2.141981e-01  2.141904e-01  2.141791e-01  2.141643e-01   
: I/Y   2.502018e-01  2.502111e-01  2.502287e-01  2.502549e-01  2.502896e-01   
: Z/Y   7.140015e-01  7.139894e-01  7.139640e-01  7.139266e-01  7.138770e-01   
: gY    2.400000e-02  2.901608e-02  2.903698e-02  2.905401e-02  2.907140e-02   
: 
:                t-1             t    difference  
: C     5.801908e+25  5.970163e+25  1.682553e+24  
: Cw    1.948123e+25  2.004619e+25  5.649557e+23  
: Ck    3.853798e+25  3.965559e+25  1.117602e+24  
: FD    3.575659e+25  3.679353e+25  1.036941e+24  
: Fn    3.886586e+25  3.999297e+25  1.127110e+24  
: ...            ...           ...           ...  
: TIME  1.050000e+03  1.051000e+03  1.000000e+00  
: Ih/Y  2.119514e-01  2.119514e-01  1.094891e-10  
: I/Y   2.554511e-01  2.554511e-01 -2.554738e-10  
: Z/Y   7.065020e-01  7.065020e-01  3.649624e-10  
: gY    2.900000e-02  2.900000e-02  1.417932e-10  
: 
: [80 rows x 8 columns]

[[file:/tmp/ob-ipython-htmlmOYzio.html]]

# text/plain
: <Figure size 1728x360 with 3 Axes>

# image/png
[[file:obipy-resources/833ba20b4aec1c9746a2e4fcac62a826eabb201d/83659ba2b3e2ae0aad89f27149fcb260b24a02fa.png]]

# text/plain
: <Figure size 1152x720 with 4 Axes>

# image/png
[[file:obipy-resources/833ba20b4aec1c9746a2e4fcac62a826eabb201d/cf1301f1049a939aebb27aca3ec93a940b6bfe9b.png]]

# text/plain
: <Figure size 1152x720 with 4 Axes>

# image/png
[[file:obipy-resources/833ba20b4aec1c9746a2e4fcac62a826eabb201d/6381ee9168a32a9ba7c12cedc582c3b91b1c8cfd.png]]

# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/833ba20b4aec1c9746a2e4fcac62a826eabb201d/c30d640ac744f4f7f5d4a29921d32bf8bf0edb34.png]]

# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/833ba20b4aec1c9746a2e4fcac62a826eabb201d/c9457bec4f138b80843085fcac1c1e97533c075e.png]]

# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/833ba20b4aec1c9746a2e4fcac62a826eabb201d/4a96f305d4603d65d8d3f9a9fb2e181ac11cd89d.png]]

# text/plain
: <Figure size 576x360 with 1 Axes>

# image/png
[[file:obipy-resources/833ba20b4aec1c9746a2e4fcac62a826eabb201d/eda91cc269f793debd12422a7d4cb65ca7f9aad0.png]]
:end:


